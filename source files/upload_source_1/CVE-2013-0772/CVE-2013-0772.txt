diff --git a/image/decoders/nsGIFDecoder2.cpp b/image/decoders/nsGIFDecoder2.cpp
--- a/image/decoders/nsGIFDecoder2.cpp
+++ b/image/decoders/nsGIFDecoder2.cpp
@@ -333,26 +333,18 @@ uint32_t nsGIFDecoder2::OutputRow()
     // Row to process
     const uint32_t bpr = sizeof(uint32_t) * mGIFStruct.width; 
     uint8_t *rowp = mImageData + (mGIFStruct.irow * bpr);
 
     // Convert color indices to Cairo pixels
     uint8_t *from = rowp + mGIFStruct.width;
     uint32_t *to = ((uint32_t*)rowp) + mGIFStruct.width;
     uint32_t *cmap = mColormap;
-    if (mColorMask == 0xFF) {
-      for (uint32_t c = mGIFStruct.width; c > 0; c--) {
-        *--to = cmap[*--from];
-      }
-    } else {
-      // Make sure that pixels within range of colormap.
-      uint8_t mask = mColorMask;
-      for (uint32_t c = mGIFStruct.width; c > 0; c--) {
-        *--to = cmap[(*--from) & mask];
-      }
+    for (uint32_t c = mGIFStruct.width; c > 0; c--) {
+      *--to = cmap[*--from];
     }
   
     // check for alpha (only for first frame)
     if (mGIFStruct.is_transparent && !mSawTransparency) {
       const uint32_t *rgb = (uint32_t*)rowp;
       for (uint32_t i = mGIFStruct.width; i > 0; i--) {
         if (*rgb++ == 0) {
           mSawTransparency = true;
@@ -462,17 +454,17 @@ nsGIFDecoder2::DoLzw(const uint8_t *q)
       if (code == (clear_code + 1)) {
         /* end-of-stream should only appear after all image data */
         return (mGIFStruct.rows_remaining == 0);
       }
 
       if (oldcode == -1) {
         if (code >= MAX_BITS)
           return false;
-        *rowp++ = suffix[code];
+        *rowp++ = suffix[code] & mColorMask; // ensure index is within colormap
         if (rowp == rowend)
           OUTPUT_ROW();
 
         firstchar = oldcode = code;
         continue;
       }
 
       int incode = code;
@@ -512,17 +504,17 @@ nsGIFDecoder2::DoLzw(const uint8_t *q)
           codesize++;
           codemask += avail;
         }
       }
       oldcode = incode;
 
       /* Copy the decoded data out to the scanline buffer. */
       do {
-        *rowp++ = *--stackp;
+        *rowp++ = *--stackp & mColorMask; // ensure index is within colormap
         if (rowp == rowend)
           OUTPUT_ROW();
       } while (stackp > stack);
     }
   }
 
   END:
