diff --git a/media/webrtc/trunk/webrtc/modules/video_capture/android/java/src/org/webrtc/videoengine/VideoCaptureAndroid.java b/media/webrtc/trunk/webrtc/modules/video_capture/android/java/src/org/webrtc/videoengine/VideoCaptureAndroid.java
--- a/media/webrtc/trunk/webrtc/modules/video_capture/android/java/src/org/webrtc/videoengine/VideoCaptureAndroid.java
+++ b/media/webrtc/trunk/webrtc/modules/video_capture/android/java/src/org/webrtc/videoengine/VideoCaptureAndroid.java
@@ -51,17 +51,17 @@ public class VideoCaptureAndroid impleme
   private static SurfaceHolder localPreview;
   // Only non-null while capturing, accessed exclusively from synchronized methods.
   Camera camera;
   private Camera.CameraInfo info;
   private CameraThread cameraThread;
   private Handler cameraThreadHandler;
   private Context context;
   private final int id;
-  private final long native_capturer;  // |VideoCaptureAndroid*| in C++.
+  private volatile long native_capturer;  // |VideoCaptureAndroid*| in C++.
   private SurfaceTexture cameraSurfaceTexture;
   private int[] cameraGlTextures = null;
 
   // Arbitrary queue depth.  Higher number means more memory allocated & held,
   // lower number means more sensitivity to processing time in the client (and
   // potentially stalling the capturer if it runs out of buffers to write to).
   private final int numCaptureBuffers = 3;
 
@@ -368,16 +368,25 @@ public class VideoCaptureAndroid impleme
       throw new RuntimeException(e);
     }
     cameraThreadHandler = null;
     cameraThread = null;
     Log.d(TAG, "stopCapture done");
     return status;
   }
 
+  @WebRTCJNITarget
+  private void unlinkCapturer() {
+    // stopCapture might fail. That might leave the callbacks dangling, so make
+    // sure those don't call into dead code.
+    // Note that onPreviewCameraFrame isn't synchronized, so there's no point in
+    // synchronizing us either. ProvideCameraFrame has to do the null check.
+    native_capturer = 0;
+  }
+
   private void stopCaptureOnCameraThread(
       Exchanger<Boolean> result) {
     if (camera == null) {
       if (mResumeCapture == true) {
         // We already got onPause, but now the native code wants us to stop.
         // Do not resume capturing when resuming the app.
         mResumeCapture = false;
         return;
diff --git a/media/webrtc/trunk/webrtc/modules/video_capture/android/video_capture_android.cc b/media/webrtc/trunk/webrtc/modules/video_capture/android/video_capture_android.cc
--- a/media/webrtc/trunk/webrtc/modules/video_capture/android/video_capture_android.cc
+++ b/media/webrtc/trunk/webrtc/modules/video_capture/android/video_capture_android.cc
@@ -36,16 +36,18 @@ jobject JNICALL GetContext(JNIEnv* env, 
 void JNICALL ProvideCameraFrame(
     JNIEnv* env,
     jobject,
     jbyteArray javaCameraFrame,
     jint length,
     jint rotation,
     jlong timeStamp,
     jlong context) {
+  if (context == 0)
+    return;
   webrtc::videocapturemodule::VideoCaptureAndroid* captureModule =
       reinterpret_cast<webrtc::videocapturemodule::VideoCaptureAndroid*>(
           context);
   jbyte* cameraFrame = env->GetByteArrayElements(javaCameraFrame, NULL);
   captureModule->OnIncomingFrame(
       reinterpret_cast<uint8_t*>(cameraFrame), length, rotation, 0);
   env->ReleaseByteArrayElements(javaCameraFrame, cameraFrame, JNI_ABORT);
 }
@@ -162,17 +164,24 @@ int32_t VideoCaptureAndroid::Init(const 
   return 0;
 }
 
 VideoCaptureAndroid::~VideoCaptureAndroid() {
   // Ensure Java camera is released even if our caller didn't explicitly Stop.
   if (_captureStarted)
     StopCapture();
   AttachThreadScoped ats(g_jvm);
-  ats.env()->DeleteGlobalRef(_jCapturer);
+  JNIEnv* env = ats.env();
+
+  // Avoid callbacks into ourself even if the above stopCapture fails.
+  jmethodID j_unlink =
+    env->GetMethodID(g_java_capturer_class, "unlinkCapturer", "()V");
+  env->CallVoidMethod(_jCapturer, j_unlink);
+
+  env->DeleteGlobalRef(_jCapturer);
 }
 
 int32_t VideoCaptureAndroid::StartCapture(
     const VideoCaptureCapability& capability) {
   CriticalSectionScoped cs(&_apiCs);
   AttachThreadScoped ats(g_jvm);
   JNIEnv* env = ats.env();
 
@@ -211,16 +220,17 @@ int32_t VideoCaptureAndroid::StopCapture
 
   memset(&_requestedCapability, 0, sizeof(_requestedCapability));
   memset(&_captureCapability, 0, sizeof(_captureCapability));
   _captureStarted = false;
   // Exit critical section to avoid blocking camera thread inside
   // onIncomingFrame() call.
   _apiCs.Leave();
 
+  // try to stop the capturer.
   jmethodID j_stop =
       env->GetMethodID(g_java_capturer_class, "stopCapture", "()Z");
   return env->CallBooleanMethod(_jCapturer, j_stop) ? 0 : -1;
 }
 
 bool VideoCaptureAndroid::CaptureStarted() {
   CriticalSectionScoped cs(&_apiCs);
   return _captureStarted;
