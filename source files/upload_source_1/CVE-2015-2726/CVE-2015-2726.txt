diff --git a/js/src/ctypes/CTypes.cpp b/js/src/ctypes/CTypes.cpp
--- a/js/src/ctypes/CTypes.cpp
+++ b/js/src/ctypes/CTypes.cpp
@@ -4958,17 +4958,17 @@ StructType::DefineInternal(JSContext* cx
       // checking fieldOffset for overflow.
       if (fieldOffset + fieldSize < structSize) {
         JS_ReportError(cx, "size overflow");
         return false;
       }
 
       // Add field name to the hash
       FieldInfo info;
-      info.mType = fieldType;
+      info.mType = nullptr; // Value of fields are not yet traceable here.
       info.mIndex = i;
       info.mOffset = fieldOffset;
       ASSERT_OK(fields->add(entryPtr, name, info));
       JS_StoreStringPostBarrierCallback(cx, PostBarrierCallback, name, fields.get());
 
       structSize = fieldOffset + fieldSize;
 
       if (fieldAlign > structAlign)
@@ -4991,16 +4991,25 @@ StructType::DefineInternal(JSContext* cx
     structSize = 1;
     structAlign = 1;
   }
 
   RootedValue sizeVal(cx);
   if (!SizeTojsval(cx, structSize, &sizeVal))
     return false;
 
+  size_t i = 0;
+  for (FieldInfoHash::Range r = fields->all(); !r.empty(); r.popFront()) {
+    FieldInfo& field = r.front().value();
+    MOZ_ASSERT(i == field.mIndex);
+    MOZ_ASSERT(i < fieldRoots.length());
+    field.mType = &fieldRoots[i].toObject();
+    i++;
+  }
+
   JS_SetReservedSlot(typeObj, SLOT_FIELDINFO, PRIVATE_TO_JSVAL(fields.release()));
 
   JS_SetReservedSlot(typeObj, SLOT_SIZE, sizeVal);
   JS_SetReservedSlot(typeObj, SLOT_ALIGN, INT_TO_JSVAL(structAlign));
   //if (!JS_FreezeObject(cx, prototype)0 // XXX fixme - see bug 541212!
   //  return false;
   JS_SetReservedSlot(typeObj, SLOT_PROTO, OBJECT_TO_JSVAL(prototype));
   return true;
diff --git a/js/src/jit-test/tests/ctypes/bug1155985.js b/js/src/jit-test/tests/ctypes/bug1155985.js
new file mode 100644
--- /dev/null
+++ b/js/src/jit-test/tests/ctypes/bug1155985.js
@@ -0,0 +1,14 @@
+function test() {
+  for (let i = 0; i < 100; i++) {
+    let test_struct = ctypes.StructType("test_struct", [{ "x": ctypes.int32_t },
+                                                        { "bar": ctypes.uint32_t }]);
+
+    try {
+      new test_struct("foo", "x");
+    } catch (e) {
+    }
+  }
+}
+
+if (typeof ctypes === "object")
+  test();
