diff --git a/dom/system/gonk/NetworkUtils.cpp b/dom/system/gonk/NetworkUtils.cpp
--- a/dom/system/gonk/NetworkUtils.cpp
+++ b/dom/system/gonk/NetworkUtils.cpp
@@ -10,16 +10,18 @@
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
 
 #include "NetworkUtils.h"
 
+#include "prprf.h"
+
 #include <android/log.h>
 #include <cutils/properties.h>
 #include <limits>
 #include "mozilla/dom/network/NetUtils.h"
 
 #include <errno.h>
 #include <string.h>
 #include <sys/types.h>  // struct addrinfo
@@ -349,21 +351,21 @@ static void join(nsTArray<nsCString>& ar
 }
 
 /**
  * Helper function to get network interface properties from the system property table.
  */
 static void getIFProperties(const char* ifname, IFProperties& prop)
 {
   char key[PROPERTY_KEY_MAX];
-  snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.gw", ifname);
+  PR_snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.gw", ifname);
   property_get(key, prop.gateway, "");
-  snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.dns1", ifname);
+  PR_snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.dns1", ifname);
   property_get(key, prop.dns1, "");
-  snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.dns2", ifname);
+  PR_snprintf(key, PROPERTY_KEY_MAX - 1, "net.%s.dns2", ifname);
   property_get(key, prop.dns2, "");
 }
 
 static int getIpType(const char *aIp) {
   struct addrinfo hint, *ip_info = NULL;
 
   memset(&hint, 0, sizeof(hint));
   hint.ai_family = AF_UNSPEC;
@@ -474,17 +476,17 @@ bool CommandResult::isPending() const
 void NetworkUtils::nextNetdCommand()
 {
   if (gCommandQueue.IsEmpty() || gPending) {
     return;
   }
 
   gCurrentCommand.chain = GET_CURRENT_CHAIN;
   gCurrentCommand.callback = GET_CURRENT_CALLBACK;
-  snprintf(gCurrentCommand.command, MAX_COMMAND_SIZE - 1, "%s", GET_CURRENT_COMMAND);
+  PR_snprintf(gCurrentCommand.command, MAX_COMMAND_SIZE - 1, "%s", GET_CURRENT_COMMAND);
 
   NU_DBG("Sending \'%s\' command to netd.", gCurrentCommand.command);
   SendNetdCommand(GET_CURRENT_NETD_COMMAND);
 
   gCommandQueue.RemoveElementAt(0);
   gPending = true;
 }
 
@@ -499,19 +501,19 @@ void NetworkUtils::nextNetdCommand()
 void NetworkUtils::doCommand(const char* aCommand, CommandChain* aChain, CommandCallback aCallback)
 {
   NU_DBG("Preparing to send \'%s\' command...", aCommand);
 
   NetdCommand* netdCommand = new NetdCommand();
 
   // Android JB version adds sequence number to netd command.
   if (SDK_VERSION >= 16) {
-    snprintf((char*)netdCommand->mData, MAX_COMMAND_SIZE - 1, "0 %s", aCommand);
+    PR_snprintf((char*)netdCommand->mData, MAX_COMMAND_SIZE - 1, "0 %s", aCommand);
   } else {
-    snprintf((char*)netdCommand->mData, MAX_COMMAND_SIZE - 1, "%s", aCommand);
+    PR_snprintf((char*)netdCommand->mData, MAX_COMMAND_SIZE - 1, "%s", aCommand);
   }
   netdCommand->mSize = strlen((char*)netdCommand->mData) + 1;
 
   gCommandQueue.AppendElement(QueueData(netdCommand, aChain, aCallback));
 
   nextNetdCommand();
 }
 
@@ -521,17 +523,17 @@ void NetworkUtils::doCommand(const char*
 #define GET_CHAR(prop) NS_ConvertUTF16toUTF8(aChain->getParams().prop).get()
 #define GET_FIELD(prop) aChain->getParams().prop
 
 void NetworkUtils::wifiFirmwareReload(CommandChain* aChain,
                                       CommandCallback aCallback,
                                       NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "softap fwreload %s %s", GET_CHAR(mIfname), GET_CHAR(mMode));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "softap fwreload %s %s", GET_CHAR(mIfname), GET_CHAR(mMode));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::startAccessPointDriver(CommandChain* aChain,
                                           CommandCallback aCallback,
                                           NetworkResultOptions& aResult)
 {
@@ -539,17 +541,17 @@ void NetworkUtils::startAccessPointDrive
   if (SDK_VERSION >= 16) {
     aResult.mResultCode = 0;
     aResult.mResultReason = NS_ConvertUTF8toUTF16("");
     aCallback(aChain, false, aResult);
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "softap start %s", GET_CHAR(mIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "softap start %s", GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::stopAccessPointDriver(CommandChain* aChain,
                                          CommandCallback aCallback,
                                          NetworkResultOptions& aResult)
 {
@@ -557,17 +559,17 @@ void NetworkUtils::stopAccessPointDriver
   if (SDK_VERSION >= 16) {
     aResult.mResultCode = 0;
     aResult.mResultReason = NS_ConvertUTF8toUTF16("");
     aCallback(aChain, false, aResult);
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "softap stop %s", GET_CHAR(mIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "softap stop %s", GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 /**
  * Command format for sdk version < 16
  *   Arguments:
  *     argv[2] - wlan interface
@@ -601,55 +603,55 @@ void NetworkUtils::setAccessPoint(Comman
   char command[MAX_COMMAND_SIZE];
   nsCString ssid(GET_CHAR(mSsid));
   nsCString key(GET_CHAR(mKey));
 
   escapeQuote(ssid);
   escapeQuote(key);
 
   if (SDK_VERSION >= 19) {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "softap set %s \"%s\" broadcast 6 %s \"%s\"",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "softap set %s \"%s\" broadcast 6 %s \"%s\"",
                      GET_CHAR(mIfname),
                      ssid.get(),
                      GET_CHAR(mSecurity),
                      key.get());
   } else if (SDK_VERSION >= 16) {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "softap set %s \"%s\" %s \"%s\"",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "softap set %s \"%s\" %s \"%s\"",
                      GET_CHAR(mIfname),
                      ssid.get(),
                      GET_CHAR(mSecurity),
                      key.get());
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "softap set %s %s \"%s\" %s \"%s\" 6 0 8",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "softap set %s %s \"%s\" %s \"%s\" 6 0 8",
                      GET_CHAR(mIfname),
                      GET_CHAR(mWifictrlinterfacename),
                      ssid.get(),
                      GET_CHAR(mSecurity),
                      key.get());
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::cleanUpStream(CommandChain* aChain,
                                  CommandCallback aCallback,
                                  NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "nat disable %s %s 0", GET_CHAR(mPreInternalIfname), GET_CHAR(mPreExternalIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "nat disable %s %s 0", GET_CHAR(mPreInternalIfname), GET_CHAR(mPreExternalIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::createUpStream(CommandChain* aChain,
                                   CommandCallback aCallback,
                                   NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "nat enable %s %s 0", GET_CHAR(mCurInternalIfname), GET_CHAR(mCurExternalIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "nat enable %s %s 0", GET_CHAR(mCurInternalIfname), GET_CHAR(mCurExternalIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::startSoftAP(CommandChain* aChain,
                                CommandCallback aCallback,
                                NetworkResultOptions& aResult)
 {
@@ -690,68 +692,68 @@ void NetworkUtils::disableAlarm(CommandC
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::setQuota(CommandChain* aChain,
                             CommandCallback aCallback,
                             NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "bandwidth setiquota %s %lld", GET_CHAR(mIfname), LLONG_MAX);
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "bandwidth setiquota %s %lld", GET_CHAR(mIfname), LLONG_MAX);
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::removeQuota(CommandChain* aChain,
                                CommandCallback aCallback,
                                NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "bandwidth removeiquota %s", GET_CHAR(mIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "bandwidth removeiquota %s", GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::setAlarm(CommandChain* aChain,
                             CommandCallback aCallback,
                             NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "bandwidth setinterfacealert %s %ld", GET_CHAR(mIfname), GET_FIELD(mThreshold));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "bandwidth setinterfacealert %s %ld", GET_CHAR(mIfname), GET_FIELD(mThreshold));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::setInterfaceUp(CommandChain* aChain,
                                   CommandCallback aCallback,
                                   NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
   if (SDK_VERSION >= 16) {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "interface setcfg %s %s %s %s",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "interface setcfg %s %s %s %s",
                      GET_CHAR(mIfname),
                      GET_CHAR(mIp),
                      GET_CHAR(mPrefix),
                      GET_CHAR(mLink));
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "interface setcfg %s %s %s [%s]",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "interface setcfg %s %s %s [%s]",
                      GET_CHAR(mIfname),
                      GET_CHAR(mIp),
                      GET_CHAR(mPrefix),
                      GET_CHAR(mLink));
   }
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::tetherInterface(CommandChain* aChain,
                                    CommandCallback aCallback,
                                    NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface add %s", GET_CHAR(mIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface add %s", GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::addInterfaceToLocalNetwork(CommandChain* aChain,
                                               CommandCallback aCallback,
                                               NetworkResultOptions& aResult)
 {
@@ -759,18 +761,18 @@ void NetworkUtils::addInterfaceToLocalNe
   if (SDK_VERSION < 20) {
     aResult.mResultCode = 0;
     aResult.mResultReason = NS_ConvertUTF8toUTF16("");
     aCallback(aChain, false, aResult);
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network interface add local %s",
-           GET_CHAR(mInternalIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network interface add local %s",
+              GET_CHAR(mInternalIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::addRouteToLocalNetwork(CommandChain* aChain,
                                           CommandCallback aCallback,
                                           NetworkResultOptions& aResult)
 {
@@ -782,43 +784,43 @@ void NetworkUtils::addRouteToLocalNetwor
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
   uint32_t prefix = atoi(GET_CHAR(mPrefix));
   uint32_t ip = inet_addr(GET_CHAR(mIp));
   char* networkAddr = getNetworkAddr(ip, prefix);
 
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network route add local %s %s/%s",
-           GET_CHAR(mInternalIfname), networkAddr, GET_CHAR(mPrefix));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network route add local %s %s/%s",
+              GET_CHAR(mInternalIfname), networkAddr, GET_CHAR(mPrefix));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::preTetherInterfaceList(CommandChain* aChain,
                                           CommandCallback aCallback,
                                           NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
   if (SDK_VERSION >= 16) {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface list");
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface list");
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface list 0");
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface list 0");
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::postTetherInterfaceList(CommandChain* aChain,
                                            CommandCallback aCallback,
                                            NetworkResultOptions& aResult)
 {
   // Send the dummy command to continue the function chain.
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "%s", DUMMY_COMMAND);
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "%s", DUMMY_COMMAND);
 
   char buf[BUF_SIZE];
   NS_ConvertUTF16toUTF8 reason(aResult.mResultReason);
   memcpy(buf, reason.get(), reason.Length() + 1);
   split(buf, INTERFACE_DELIMIT, GET_FIELD(mInterfaceList));
 
   doCommand(command, aChain, aCallback);
 }
@@ -866,18 +868,18 @@ void NetworkUtils::addUpstreamInterface(
   }
 
   if (SUPPORT_IPV6_TETHERING == 0 || !isCommandChainIPv6(aChain, interface.get())) {
     aCallback(aChain, false, aResult);
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface add_upstream %s",
-           interface.get());
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface add_upstream %s",
+              interface.get());
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::removeUpstreamInterface(CommandChain* aChain,
                                            CommandCallback aCallback,
                                            NetworkResultOptions& aResult)
 {
   nsCString interface(GET_CHAR(mExternalIfname));
@@ -886,36 +888,36 @@ void NetworkUtils::removeUpstreamInterfa
   }
 
   if (SUPPORT_IPV6_TETHERING == 0 || !isCommandChainIPv6(aChain, interface.get())) {
     aCallback(aChain, false, aResult);
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface remove_upstream %s",
-           interface.get());
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface remove_upstream %s",
+              interface.get());
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::setIpForwardingEnabled(CommandChain* aChain,
                                           CommandCallback aCallback,
                                           NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
 
   if (GET_FIELD(mEnable)) {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "ipfwd enable");
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "ipfwd enable");
   } else {
     // Don't disable ip forwarding because others interface still need it.
     // Send the dummy command to continue the function chain.
     if (GET_FIELD(mInterfaceList).Length() > 1) {
-      snprintf(command, MAX_COMMAND_SIZE - 1, "%s", DUMMY_COMMAND);
+      PR_snprintf(command, MAX_COMMAND_SIZE - 1, "%s", DUMMY_COMMAND);
     } else {
-      snprintf(command, MAX_COMMAND_SIZE - 1, "ipfwd disable");
+      PR_snprintf(command, MAX_COMMAND_SIZE - 1, "ipfwd disable");
     }
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::tetheringStatus(CommandChain* aChain,
                                    CommandCallback aCallback,
@@ -929,57 +931,57 @@ void NetworkUtils::stopTethering(Command
                                  CommandCallback aCallback,
                                  NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
 
   // Don't stop tethering because others interface still need it.
   // Send the dummy to continue the function chain.
   if (GET_FIELD(mInterfaceList).Length() > 1) {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "%s", DUMMY_COMMAND);
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "%s", DUMMY_COMMAND);
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "tether stop");
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether stop");
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::startTethering(CommandChain* aChain,
                                   CommandCallback aCallback,
                                   NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
 
   // We don't need to start tethering again.
   // Send the dummy command to continue the function chain.
   if (aResult.mResultReason.Find("started") != kNotFound) {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "%s", DUMMY_COMMAND);
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "%s", DUMMY_COMMAND);
   } else {
     // If usbStartIp/usbEndIp is not valid, don't append them since
     // the trailing white spaces will be parsed to extra empty args
     // See: http://androidxref.com/4.3_r2.1/xref/system/core/libsysutils/src/FrameworkListener.cpp#78
     if (!GET_FIELD(mUsbStartIp).IsEmpty() && !GET_FIELD(mUsbEndIp).IsEmpty()) {
-      snprintf(command, MAX_COMMAND_SIZE - 1, "tether start %s %s %s %s",
-               GET_CHAR(mWifiStartIp), GET_CHAR(mWifiEndIp),
-               GET_CHAR(mUsbStartIp),  GET_CHAR(mUsbEndIp));
+      PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether start %s %s %s %s",
+                  GET_CHAR(mWifiStartIp), GET_CHAR(mWifiEndIp),
+                  GET_CHAR(mUsbStartIp),  GET_CHAR(mUsbEndIp));
     } else {
-      snprintf(command, MAX_COMMAND_SIZE - 1, "tether start %s %s",
-               GET_CHAR(mWifiStartIp), GET_CHAR(mWifiEndIp));
+      PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether start %s %s",
+                  GET_CHAR(mWifiStartIp), GET_CHAR(mWifiEndIp));
     }
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::untetherInterface(CommandChain* aChain,
                                      CommandCallback aCallback,
                                      NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface remove %s", GET_CHAR(mIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether interface remove %s", GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::removeInterfaceFromLocalNetwork(CommandChain* aChain,
                                                    CommandCallback aCallback,
                                                    NetworkResultOptions& aResult)
 {
@@ -987,34 +989,34 @@ void NetworkUtils::removeInterfaceFromLo
   if (SDK_VERSION < 20) {
     aResult.mResultCode = 0;
     aResult.mResultReason = NS_ConvertUTF8toUTF16("");
     aCallback(aChain, false, aResult);
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network interface remove local %s",
-           GET_CHAR(mIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network interface remove local %s",
+              GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::setDnsForwarders(CommandChain* aChain,
                                     CommandCallback aCallback,
                                     NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
 
   if (SDK_VERSION >= 20) {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "tether dns set %d %s %s",
-             GET_FIELD(mNetId), GET_CHAR(mDns1), GET_CHAR(mDns2));
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether dns set %d %s %s",
+                GET_FIELD(mNetId), GET_CHAR(mDns1), GET_CHAR(mDns2));
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "tether dns set %s %s",
-             GET_CHAR(mDns1), GET_CHAR(mDns2));
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "tether dns set %s %s",
+                GET_CHAR(mDns1), GET_CHAR(mDns2));
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::enableNat(CommandChain* aChain,
                              CommandCallback aCallback,
                              NetworkResultOptions& aResult)
@@ -1022,21 +1024,21 @@ void NetworkUtils::enableNat(CommandChai
   char command[MAX_COMMAND_SIZE];
 
   if (!GET_FIELD(mIp).IsEmpty() && !GET_FIELD(mPrefix).IsEmpty()) {
     uint32_t prefix = atoi(GET_CHAR(mPrefix));
     uint32_t ip = inet_addr(GET_CHAR(mIp));
     char* networkAddr = getNetworkAddr(ip, prefix);
 
     // address/prefix will only take effect when secondary routing table exists.
-    snprintf(command, MAX_COMMAND_SIZE - 1, "nat enable %s %s 1 %s/%s",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "nat enable %s %s 1 %s/%s",
       GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname), networkAddr,
       GET_CHAR(mPrefix));
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "nat enable %s %s 0",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "nat enable %s %s 0",
       GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname));
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::disableNat(CommandChain* aChain,
                               CommandCallback aCallback,
@@ -1044,33 +1046,33 @@ void NetworkUtils::disableNat(CommandCha
 {
   char command[MAX_COMMAND_SIZE];
 
   if (!GET_FIELD(mIp).IsEmpty() && !GET_FIELD(mPrefix).IsEmpty()) {
     uint32_t prefix = atoi(GET_CHAR(mPrefix));
     uint32_t ip = inet_addr(GET_CHAR(mIp));
     char* networkAddr = getNetworkAddr(ip, prefix);
 
-    snprintf(command, MAX_COMMAND_SIZE - 1, "nat disable %s %s 1 %s/%s",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "nat disable %s %s 1 %s/%s",
       GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname), networkAddr,
       GET_CHAR(mPrefix));
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1, "nat disable %s %s 0",
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1, "nat disable %s %s 0",
       GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname));
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::setDefaultInterface(CommandChain* aChain,
                                        CommandCallback aCallback,
                                        NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "resolver setdefaultif %s", GET_CHAR(mIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "resolver setdefaultif %s", GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::removeDefaultRoute(CommandChain* aChain,
                                       CommandCallback aCallback,
                                       NetworkResultOptions& aResult)
 {
@@ -1079,19 +1081,19 @@ void NetworkUtils::removeDefaultRoute(Co
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
   nsTArray<nsString>& gateways = GET_FIELD(mGateways);
   NS_ConvertUTF16toUTF8 autoGateway(gateways[GET_FIELD(mLoopIndex)]);
 
   int type = getIpType(autoGateway.get());
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network route remove %d %s %s/0 %s",
-           GET_FIELD(mNetId), GET_CHAR(mIfname),
-           type == AF_INET6 ? "::" : "0.0.0.0", autoGateway.get());
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network route remove %d %s %s/0 %s",
+              GET_FIELD(mNetId), GET_CHAR(mIfname),
+              type == AF_INET6 ? "::" : "0.0.0.0", autoGateway.get());
 
   struct MyCallback {
     static void callback(CommandCallback::CallbackType aOriginalCallback,
                          CommandChain* aChain,
                          bool aError,
                          mozilla::dom::NetworkResultOptions& aResult)
     {
       NS_ConvertUTF16toUTF8 reason(aResult.mResultReason);
@@ -1112,30 +1114,30 @@ void NetworkUtils::removeDefaultRoute(Co
 void NetworkUtils::setInterfaceDns(CommandChain* aChain,
                                    CommandCallback aCallback,
                                    NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
   int written;
 
   if (SDK_VERSION >= 20) {
-    written = snprintf(command, sizeof command, "resolver setnetdns %d %s",
-                                                GET_FIELD(mNetId), GET_CHAR(mDomain));
+    written = PR_snprintf(command, sizeof command, "resolver setnetdns %d %s",
+                                                   GET_FIELD(mNetId), GET_CHAR(mDomain));
   } else {
-    written = snprintf(command, sizeof command, "resolver setifdns %s %s",
-                                                GET_CHAR(mIfname), GET_CHAR(mDomain));
+    written = PR_snprintf(command, sizeof command, "resolver setifdns %s %s",
+                                                   GET_CHAR(mIfname), GET_CHAR(mDomain));
   }
 
   nsTArray<nsString>& dnses = GET_FIELD(mDnses);
   uint32_t length = dnses.Length();
 
   for (uint32_t i = 0; i < length; i++) {
     NS_ConvertUTF16toUTF8 autoDns(dnses[i]);
 
-    int ret = snprintf(command + written, sizeof(command) - written, " %s", autoDns.get());
+    int ret = PR_snprintf(command + written, sizeof(command) - written, " %s", autoDns.get());
     if (ret <= 1) {
       command[written] = '\0';
       continue;
     }
 
     if (((size_t)ret + written) >= sizeof(command)) {
       command[written] = '\0';
       break;
@@ -1147,47 +1149,47 @@ void NetworkUtils::setInterfaceDns(Comma
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::clearAddrForInterface(CommandChain* aChain,
                                          CommandCallback aCallback,
                                          NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "interface clearaddrs %s", GET_CHAR(mIfname));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "interface clearaddrs %s", GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::createNetwork(CommandChain* aChain,
                                  CommandCallback aCallback,
                                  NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network create %d", GET_FIELD(mNetId));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network create %d", GET_FIELD(mNetId));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::destroyNetwork(CommandChain* aChain,
                                   CommandCallback aCallback,
                                   NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network destroy %d", GET_FIELD(mNetId));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network destroy %d", GET_FIELD(mNetId));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::addInterfaceToNetwork(CommandChain* aChain,
                                          CommandCallback aCallback,
                                          NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network interface add %d %s",
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network interface add %d %s",
                     GET_FIELD(mNetId), GET_CHAR(mIfname));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::addRouteToInterface(CommandChain* aChain,
                                        CommandCallback aCallback,
                                        NetworkResultOptions& aResult)
@@ -1237,20 +1239,20 @@ void NetworkUtils::modifyRouteOnInterfac
     ipOrSubnetIp = getSubnetIp(ipOrSubnetIp, GET_FIELD(mPrefixLength));
     legacyOrEmpty = ""; // Add to interface table for scope link route.
   } else {
     gatewayOrEmpty = nsCString(" ") + NS_ConvertUTF16toUTF8(GET_FIELD(mGateway));
   }
 
   const char* action = aDoAdd ? "add" : "remove";
 
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network route %s%s %d %s %s/%d%s",
-           legacyOrEmpty, action,
-           GET_FIELD(mNetId), GET_CHAR(mIfname), ipOrSubnetIp.get(),
-           GET_FIELD(mPrefixLength), gatewayOrEmpty.get());
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network route %s%s %d %s %s/%d%s",
+              legacyOrEmpty, action,
+              GET_FIELD(mNetId), GET_CHAR(mIfname), ipOrSubnetIp.get(),
+              GET_FIELD(mPrefixLength), gatewayOrEmpty.get());
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::addDefaultRouteToNetwork(CommandChain* aChain,
                                             CommandCallback aCallback,
                                             NetworkResultOptions& aResult)
 {
@@ -1259,19 +1261,19 @@ void NetworkUtils::addDefaultRouteToNetw
     return;
   }
 
   char command[MAX_COMMAND_SIZE];
   nsTArray<nsString>& gateways = GET_FIELD(mGateways);
   NS_ConvertUTF16toUTF8 autoGateway(gateways[GET_FIELD(mLoopIndex)]);
 
   int type = getIpType(autoGateway.get());
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network route add %d %s %s/0 %s",
-           GET_FIELD(mNetId), GET_CHAR(mIfname),
-           type == AF_INET6 ? "::" : "0.0.0.0", autoGateway.get());
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network route add %d %s %s/0 %s",
+              GET_FIELD(mNetId), GET_CHAR(mIfname),
+              type == AF_INET6 ? "::" : "0.0.0.0", autoGateway.get());
 
   struct MyCallback {
     static void callback(CommandCallback::CallbackType aOriginalCallback,
                          CommandChain* aChain,
                          bool aError,
                          mozilla::dom::NetworkResultOptions& aResult)
     {
       NS_ConvertUTF16toUTF8 reason(aResult.mResultReason);
@@ -1289,80 +1291,80 @@ void NetworkUtils::addDefaultRouteToNetw
   doCommand(command, aChain, wrappedCallback);
 }
 
 void NetworkUtils::setDefaultNetwork(CommandChain* aChain,
                                      CommandCallback aCallback,
                                      NetworkResultOptions& aResult)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "network default set %d", GET_FIELD(mNetId));
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "network default set %d", GET_FIELD(mNetId));
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::addRouteToSecondaryTable(CommandChain* aChain,
                                             CommandCallback aCallback,
                                             NetworkResultOptions& aResult) {
 
   char command[MAX_COMMAND_SIZE];
 
   if (SDK_VERSION >= 20) {
-    snprintf(command, MAX_COMMAND_SIZE - 1,
-             "network route add %d %s %s/%s %s",
-             GET_FIELD(mNetId),
-             GET_CHAR(mIfname),
-             GET_CHAR(mIp),
-             GET_CHAR(mPrefix),
-             GET_CHAR(mGateway));
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1,
+                "network route add %d %s %s/%s %s",
+                GET_FIELD(mNetId),
+                GET_CHAR(mIfname),
+                GET_CHAR(mIp),
+                GET_CHAR(mPrefix),
+                GET_CHAR(mGateway));
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1,
-             "interface route add %s secondary %s %s %s",
-             GET_CHAR(mIfname),
-             GET_CHAR(mIp),
-             GET_CHAR(mPrefix),
-             GET_CHAR(mGateway));
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1,
+                "interface route add %s secondary %s %s %s",
+                GET_CHAR(mIfname),
+                GET_CHAR(mIp),
+                GET_CHAR(mPrefix),
+                GET_CHAR(mGateway));
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::removeRouteFromSecondaryTable(CommandChain* aChain,
                                                  CommandCallback aCallback,
                                                  NetworkResultOptions& aResult) {
   char command[MAX_COMMAND_SIZE];
 
   if (SDK_VERSION >= 20) {
-    snprintf(command, MAX_COMMAND_SIZE - 1,
-             "network route remove %d %s %s/%s %s",
-             GET_FIELD(mNetId),
-             GET_CHAR(mIfname),
-             GET_CHAR(mIp),
-             GET_CHAR(mPrefix),
-             GET_CHAR(mGateway));
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1,
+                "network route remove %d %s %s/%s %s",
+                GET_FIELD(mNetId),
+                GET_CHAR(mIfname),
+                GET_CHAR(mIp),
+                GET_CHAR(mPrefix),
+                GET_CHAR(mGateway));
   } else {
-    snprintf(command, MAX_COMMAND_SIZE - 1,
-             "interface route remove %s secondary %s %s %s",
-             GET_CHAR(mIfname),
-             GET_CHAR(mIp),
-             GET_CHAR(mPrefix),
-             GET_CHAR(mGateway));
+    PR_snprintf(command, MAX_COMMAND_SIZE - 1,
+                "interface route remove %s secondary %s %s %s",
+                GET_CHAR(mIfname),
+                GET_CHAR(mIp),
+                GET_CHAR(mPrefix),
+                GET_CHAR(mGateway));
   }
 
   doCommand(command, aChain, aCallback);
 }
 
 void NetworkUtils::setIpv6Enabled(CommandChain* aChain,
                                   CommandCallback aCallback,
                                   NetworkResultOptions& aResult,
                                   bool aEnabled)
 {
   char command[MAX_COMMAND_SIZE];
-  snprintf(command, MAX_COMMAND_SIZE - 1, "interface ipv6 %s %s",
-           GET_CHAR(mIfname), aEnabled ? "enable" : "disable");
+  PR_snprintf(command, MAX_COMMAND_SIZE - 1, "interface ipv6 %s %s",
+              GET_CHAR(mIfname), aEnabled ? "enable" : "disable");
 
   struct MyCallback {
     static void callback(CommandCallback::CallbackType aOriginalCallback,
                          CommandChain* aChain,
                          bool aError,
                          mozilla::dom::NetworkResultOptions& aResult)
     {
       aOriginalCallback(aChain, false, aResult);
@@ -1682,19 +1684,19 @@ void NetworkUtils::onNetdMessage(NetdCom
   if (isBroadcastMessage(code)) {
     NU_DBG("Receiving broadcast message from netd.");
     NU_DBG("          ==> Code: %d  Reason: %s", code, reason);
     sendBroadcastMessage(code, reason);
 
     if (code == NETD_COMMAND_INTERFACE_CHANGE) {
       if (gWifiTetheringParms) {
         char linkdownReason[MAX_COMMAND_SIZE];
-        snprintf(linkdownReason, MAX_COMMAND_SIZE - 1,
-                 "Iface linkstate %s down",
-                 NS_ConvertUTF16toUTF8(gWifiTetheringParms->mIfname).get());
+        PR_snprintf(linkdownReason, MAX_COMMAND_SIZE - 1,
+                    "Iface linkstate %s down",
+                    NS_ConvertUTF16toUTF8(gWifiTetheringParms->mIfname).get());
 
         if (!strcmp(reason, linkdownReason)) {
           NU_DBG("Wifi link down, restarting tethering.");
           runChain(*gWifiTetheringParms, sWifiRetryChain, wifiTetheringFail);
         }
       }
     }
 
@@ -1761,34 +1763,34 @@ CommandResult NetworkUtils::setDNS(Netwo
 {
   uint32_t length = aOptions.mDnses.Length();
 
   if (length > 0) {
     for (uint32_t i = 0; i < length; i++) {
       NS_ConvertUTF16toUTF8 autoDns(aOptions.mDnses[i]);
 
       char dns_prop_key[PROPERTY_VALUE_MAX];
-      snprintf(dns_prop_key, sizeof dns_prop_key, "net.dns%d", i+1);
+      PR_snprintf(dns_prop_key, sizeof dns_prop_key, "net.dns%d", i+1);
       property_set(dns_prop_key, autoDns.get());
     }
   } else {
     // Set dnses from system properties.
     IFProperties interfaceProperties;
     getIFProperties(GET_CHAR(mIfname), interfaceProperties);
 
     property_set("net.dns1", interfaceProperties.dns1);
     property_set("net.dns2", interfaceProperties.dns2);
   }
 
   // Bump the DNS change property.
   char dnschange[PROPERTY_VALUE_MAX];
   property_get("net.dnschange", dnschange, "0");
 
   char num[PROPERTY_VALUE_MAX];
-  snprintf(num, PROPERTY_VALUE_MAX - 1, "%d", atoi(dnschange) + 1);
+  PR_snprintf(num, PROPERTY_VALUE_MAX - 1, "%d", atoi(dnschange) + 1);
   property_set("net.dnschange", num);
 
   // DNS needs to be set through netd since JellyBean (4.3).
   if (SDK_VERSION >= 20) {
     // Lollipop.
     static CommandFunc COMMAND_CHAIN[] = {
       setInterfaceDns,
       addDefaultRouteToNetwork,
@@ -1976,17 +1978,17 @@ CommandResult NetworkUtils::setDefaultRo
         RETURN_IF_FAILED(mNetUtils->do_ifc_set_default_route(autoIfname.get(), inet_addr(autoGateway.get())));
       }
     }
   } else {
     // Set default froute from system properties.
     char key[PROPERTY_KEY_MAX];
     char gateway[PROPERTY_KEY_MAX];
 
-    snprintf(key, sizeof key - 1, "net.%s.gw", autoIfname.get());
+    PR_snprintf(key, sizeof key - 1, "net.%s.gw", autoIfname.get());
     property_get(key, gateway, "");
 
     int type = getIpType(gateway);
     if (type != AF_INET && type != AF_INET6) {
       return EAFNOSUPPORT;
     }
 
     if (type == AF_INET6) {
diff --git a/dom/wifi/WifiUtils.cpp b/dom/wifi/WifiUtils.cpp
--- a/dom/wifi/WifiUtils.cpp
+++ b/dom/wifi/WifiUtils.cpp
@@ -363,20 +363,20 @@ public:
     return wifi_stop_supplicant(arg);
   }
 
   DEFINE_DLFUNC(wifi_command, int32_t, const char*, char*, size_t*)
   int32_t do_wifi_command(const char* iface, const char* cmd, char* buf, size_t* len) {
     char command[COMMAND_SIZE];
     if (!strcmp(iface, "p2p0")) {
       // Commands for p2p0 interface don't need prefix
-      snprintf(command, COMMAND_SIZE, "%s", cmd);
+      PR_snprintf(command, COMMAND_SIZE, "%s", cmd);
     }
     else {
-      snprintf(command, COMMAND_SIZE, "IFNAME=%s %s", iface, cmd);
+      PR_snprintf(command, COMMAND_SIZE, "IFNAME=%s %s", iface, cmd);
     }
     USE_DLFUNC(wifi_command)
     return wifi_command(command, buf, len);
   }
 };
 
 // Concrete class to use to access the wpa supplicant.
 WpaSupplicant::WpaSupplicant()
