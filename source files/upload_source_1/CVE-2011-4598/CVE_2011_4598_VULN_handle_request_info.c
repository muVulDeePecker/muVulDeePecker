static void CVE_2011_4598_VULN_handle_request_info(struct sip_pvt *p, struct sip_request *req)
{
	char buf[1024];
	unsigned int event;
	const char *c = get_header(req, "Content-Type");

	/* Need to check the media/type */
	if (!strcasecmp(c, "application/dtmf-relay") ||
	    !strcasecmp(c, "application/vnd.nortelnetworks.digits")) {
		unsigned int duration = 0;

		if (!p->owner) {	/* not a PBX call */
			transmit_response(p, "481 Call leg/transaction does not exist", req);
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			return;
		}

		/* Try getting the "signal=" part */
		if (ast_strlen_zero(c = get_body(req, "Signal", '=')) && ast_strlen_zero(c = get_body(req, "d", '='))) {
			ast_log(LOG_WARNING, "Unable to retrieve DTMF signal from INFO message from %s\n", p->callid);
			transmit_response(p, "200 OK", req); /* Should return error */
			return;
		} else {
			ast_copy_string(buf, c, sizeof(buf));
		}

		if (!ast_strlen_zero((c = get_body(req, "Duration", '='))))
			duration = atoi(c);
		if (!duration)
			duration = 100; /* 100 ms */


		if (ast_strlen_zero(buf)) {
			transmit_response(p, "200 OK", req);
			return;
		}

		if (buf[0] == '*')
			event = 10;
		else if (buf[0] == '#')
			event = 11;
		else if ((buf[0] >= 'A') && (buf[0] <= 'D'))
			event = 12 + buf[0] - 'A';
		else if (buf[0] == '!')
			event = 16;
		else
			event = atoi(buf);
		if (event == 16) {
			/* send a FLASH event */
			struct ast_frame f = { AST_FRAME_CONTROL, { AST_CONTROL_FLASH, } };
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event received: FLASH\n");
		} else {
			/* send a DTMF event */
			struct ast_frame f = { AST_FRAME_DTMF, };
			if (event < 10) {
				f.subclass.integer = '0' + event;
			} else if (event == 10) {
				f.subclass.integer = '*';
			} else if (event == 11) {
				f.subclass.integer = '#';
			} else if (event < 16) {
				f.subclass.integer = 'A' + (event - 12);
			}
			f.len = duration;
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event received: %c\n", (int) f.subclass.integer);
		}
		transmit_response(p, "200 OK", req);
		return;
	} else if (!strcasecmp(c, "application/dtmf")) {
		/*! \todo Note: Doesn't read the duration of the DTMF. Should be fixed. */
		unsigned int duration = 0;

		if (!p->owner) {	/* not a PBX call */
			transmit_response(p, "481 Call leg/transaction does not exist", req);
			sip_scheddestroy(p, DEFAULT_TRANS_TIMEOUT);
			return;
		}

		get_msg_text(buf, sizeof(buf), req, TRUE);
		duration = 100; /* 100 ms */

		if (ast_strlen_zero(buf)) {
			transmit_response(p, "200 OK", req);
			return;
		}
		event = atoi(buf);
		if (event == 16) {
			/* send a FLASH event */
			struct ast_frame f = { AST_FRAME_CONTROL, { AST_CONTROL_FLASH }, };
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event received: FLASH\n");
		} else {
			/* send a DTMF event */
			struct ast_frame f = { AST_FRAME_DTMF, };
			if (event < 10) {
				f.subclass.integer = '0' + event;
			} else if (event == 10) {
				f.subclass.integer = '*';
			} else if (event == 11) {
				f.subclass.integer = '#';
			} else if (event < 16) {
				f.subclass.integer = 'A' + (event - 12);
			}
			f.len = duration;
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event received: %c\n", (int) f.subclass.integer);
		}
		transmit_response(p, "200 OK", req);
		return;

	} else if (!strcasecmp(c, "application/media_control+xml")) {
		/* Eh, we'll just assume it's a fast picture update for now */
		if (p->owner)
			ast_queue_control(p->owner, AST_CONTROL_VIDUPDATE);
		transmit_response(p, "200 OK", req);
		return;
	} else if (!ast_strlen_zero(c = get_header(req, "X-ClientCode"))) {
		/* Client code (from SNOM phone) */
		if (ast_test_flag(&p->flags[0], SIP_USECLIENTCODE)) {
			if (p->owner && p->owner->cdr)
				ast_cdr_setuserfield(p->owner, c);
			if (p->owner && ast_bridged_channel(p->owner) && ast_bridged_channel(p->owner)->cdr)
				ast_cdr_setuserfield(ast_bridged_channel(p->owner), c);
			transmit_response(p, "200 OK", req);
		} else {
			transmit_response(p, "403 Forbidden", req);
		}
		return;
	} else if (!ast_strlen_zero(c = get_header(req, "Record"))) {
		/* INFO messages generated by some phones to start/stop recording
			on phone calls.
			OEJ: I think this should be something that is enabled/disabled
			per device. I don't want incoming callers to record calls in my
			pbx.
		*/
		/* first, get the feature string, if it exists */
		struct ast_call_feature *feat;
		int j;
		struct ast_frame f = { AST_FRAME_DTMF, };

		ast_rdlock_call_features();
		feat = ast_find_call_feature("automon");
		if (!feat || ast_strlen_zero(feat->exten)) {
			ast_log(LOG_WARNING, "Recording requested, but no One Touch Monitor registered. (See features.conf)\n");
			/* 403 means that we don't support this feature, so don't request it again */
			transmit_response(p, "403 Forbidden", req);
			ast_unlock_call_features();
			return;
		}
		/* Send the feature code to the PBX as DTMF, just like the handset had sent it */
		f.len = 100;
		for (j=0; j < strlen(feat->exten); j++) {
			f.subclass.integer = feat->exten[j];
			ast_queue_frame(p->owner, &f);
			if (sipdebug)
				ast_verbose("* DTMF-relay event faked: %c\n", f.subclass.integer);
		}
		ast_unlock_call_features();

		ast_debug(1, "Got a Request to Record the channel, state %s\n", c);
		transmit_response(p, "200 OK", req);
		return;
	} else if (ast_strlen_zero(c = get_header(req, "Content-Length")) || !strcasecmp(c, "0")) {
		/* This is probably just a packet making sure the signalling is still up, just send back a 200 OK */
		transmit_response(p, "200 OK", req);
		return;
	}

	/* Other type of INFO message, not really understood by Asterisk */
	/* if (get_msg_text(buf, sizeof(buf), req)) { */

	ast_log(LOG_WARNING, "Unable to parse INFO message from %s. Content %s\n", p->callid, buf);
	transmit_response(p, "415 Unsupported media type", req);
	return;
}